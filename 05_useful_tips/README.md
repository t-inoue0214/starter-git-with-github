# 05. 現場で役立つ便利機能：Stash, Ignore, Tag

ここでは、毎日の開発をよりスムーズかつ安全に進めるための、3つの重要な機能を紹介します。

## 1. ゴミを無視する `.gitignore`

Gitは「全てのファイル」を管理しようとしますが、管理したくないファイルもあります。

- **OSの自動生成ファイル:** `.DS_Store` (Mac), `Thumbs.db` (Windows)
- **ビルド生成物:** `node_modules/`, `target/`, `bin/`
- **機密情報:** `password.txt`, `.env` (APIキーなど)

これらを誤ってコミットすると、以下のようなトラブルにつながります。

- リポジトリが重くなる
- **セキュリティ事故**
- コード差分が多くなり、コミット漏れが増える

### gitignoreの設定方法

リポジトリのルート（一番上）に `.gitignore` という名前のファイルを作ります。
中身に「無視したいファイル名やフォルダ名」を記述します。

```text
# .gitignore の記述例

# 秘密のファイル（絶対コミットしない！）
secret_config.json
*.key

# 依存ライブラリ（重いので除外）
node_modules/
vendor/

# OSのゴミ
.DS_Store
```

**ポイント:**

`.gitignore`に書いておけば、`git add .` をしても、それらのファイルは無視（除外）されます。 現場のリポジトリには必ずこのファイルがあります。

**「何が除外されているか」** を最初に確認する癖をつけましょう。

## 2. 作業の一時退避 `git stash`

開発現場でよくあるシチュエーションです。

- 「機能Aを開発中（書きかけ）。まだエラーが出るからコミットはできない...」 **リーダー「緊急のバグ修正頼む！すぐに別のブランチで作業して！」**

書きかけのファイルをそのままにしてブランチを切り替えると、エラーが出たり、変更が混ざってしまいます。

そんな時に使うのが 「**一時退避（Stash）**」 です。

1. 変更を一時的に隠す

    ```bash
    # メッセージ付きで隠す（推奨）
    git stash save "機能Aの作業途中"
    ```

    これで、変更していたファイルが元に戻り、作業ディレクトリが綺麗になります。安心してブランチを切り替えられます。

1. 退避したリストを見る

    ```bash
    git stash list
    # stash@{0}: On main: 機能Aの作業途中 ...
    ```

1. 変更を戻す（復元する）

    緊急対応が終わって元のブランチに戻ってきたら、隠していた作業を取り出します。

    ```bash
    # 最新の退避内容を戻して、リストから消す
    git stash pop
    ```

ただし、いくらでも保存しておける魔法の方法でありません。

再び戻すときにスタッシュした内容と現在の編集中ファイルがあれば競合を引き起こします。

スタッシュする際は、スタッシュしたい最小限のファイルをスタッシュしてください。

また、使わなくなったらすぐに削除することを推奨します。

## 3. リリースの目印 `git tag`

コミットID（a1b2c...）は覚えにくいので、特定のコミットに「v1.0.0」のような分かりやすい名札をつける機能です。

あまり自分で作成することはないと思いますが、オープンソースのフレームワークはタグを指定してクローンすることがあるので、機能としては覚えておいてください。

```bash
# タグをつける
git tag v1.0.0

# タグをサーバーに送る（通常はタグは送られません）
git push origin v1.0.0
```

**注意点：** タグは自動でPushされない

通常の git push ではタグはサーバーに送られません。明示的に送る必要があります。

```bash
git push origin v1.0.0
```

## 5. 【コラム】設定はどこにある？ (`git config` の優先度)

最初の章で `git config --global user.name` を設定しましたが、実は設定場所は **3箇所** あります。

「現場のPCで `user.name` を設定したはずなのに、コミットしたら違う名前になっていた！」という事故を防ぐために、優先順位を覚えましょう。

### 3つの設定場所と優先度

Gitは以下の順で設定を読み込みます。**「下に行くほど（リポジトリに近いほど）優先される」** と覚えてください。

| 優先順位 | スコープ | 場所 | 説明 |
| :--- | :--- | :--- | :--- |
| **低** | **System** | `/etc/gitconfig` | PCを利用する全ユーザー共通（管理者権限が必要） |
| **中** | **Global** | `~/.gitconfig` | あなた専用の設定（`--global` で設定するのはこれ） |
| **高** | **Local** | `.git/config` | **そのリポジトリ専用の設定** |

### よくあるトラブルと解決策

**Q. 普段は「会社のアドレス」を使っているけど、このリポジトリだけ「個人のアドレス」にしたい。**

**A. `Local` 設定を使います。**
そのリポジトリのフォルダに移動して、`--global` を付けずに設定コマンドを打ちます。

```bash
# このリポジトリだけ設定を上書きする
git config user.email "my_private_email@example.com"
```

### 設定の確認方法

「今、どの設定が適用されているか」を知るには、以下のコマンドが最強です。

```bash
# どこで設定されているか（ファイルの場所）まで表示する
git config --list --show-origin
```

## 6. 自社のリポジトリにPUSHする（リモートの追加）

「基本は自分の学習用Github（origin）だが、自社の学習だけは別のGithubに送りたい」 というケースがあります。

`git push` の後に URL を直接書くこともできますが、毎回長いURLを打つのは大変です。

「宛先（リモート）」を追加登録 する方法を覚えましょう。

### 手順

現在の宛先を確認します。通常は `origin` に `clone` した先のURLが登録されています。

```bash
git remote -v
# origin  https://github.com/t-inoue0214/starter-git-and-github.git (fetch)
# origin  https://github.com/t-inoue0214/starter-git-and-github.git (push)
```

ここに、自社のリポジトリを my-company という名前で追加します。

```bash
# 書式: git remote add <好きな名前> <URL(github.com の前にアットマークの前にアカウント名を入れる)>
git remote add my-company https://t-inoue0214@github.com/t-inoue0214/starter-git-and-github.git
```

### 使い分け

プッシュする時に、宛先の名前を指定して切り替えます。

```bash
# 現場（origin）に送る場合
git push origin main

# 自社（my-company）に送る場合
git push my-company main
```

**【重要】** セキュリティの注意  
現場のソースコード（機密情報）を、誤って自社のリポジトリにPushしてしまうと情報漏洩になります。  
「どのファイルを」「どこに送ろうとしているか」、Pushする前に必ず確認しましょう。

## 7. 調査テクニック：過去を追跡する

トラブル対応で必須となる「犯人探し」や「差分確認」のコマンドです。

### 7-1. コミットログを検索する

「あのバグ修正いつやったっけ？」を調べる時。

```bash
# コミットメッセージから検索
git log --grep="バグ修正"

# コードの中身（追加・削除された行）から検索（通称: Pickaxe）
# "password" という文字列を誤ってコミットした場所を探す時などに便利
git log -S "password"
```

### 7-2. ファイル単体の歴史を見る

リポジトリ全体ではなく、「今開いているこのファイル」 が過去どう変更されてきたか（コミットID）を調べます。

```bash
# ファイル名を指定してログを表示
git log index.html

# 変更の中身（差分）まで一緒に見る
git log -p index.html
```

### 7-3. 過去の変更内容を確認する（Diff）

上で調べたコミットID（例: `a1b2c`）を使って、「具体的に何が変わったか」を見ます。

```bash
# そのコミットでのファイルの変更点を見る
git show a1b2c index.html
```

### 7-4. ブランチ間の差分をすべて確認する

リリース作業や切り戻し（Revert）を行った後、「本当に本番環境（main）と開発環境（develop）に差分がないか？」を確認する重要な操作です。

```bash
# main と develop の差分をすべて表示
git diff main develop

# 差分がある「ファイル名だけ」を表示（中身は見ない）
git diff --name-only main develop
```

何も表示されなければ、2つのブランチは完全に一致しています。

## 8. 長期間の作業中に最新を取り込む（リバースマージ）

自分のブランチ（feature/A）で開発中に、他の人の緊急対応（feature/B）などが先に `develop` にマージされることがあります。

特に、バージョン番号などの共通ファイルが更新されている場合、自分の開発が終わってからマージしようとするとコンフリクト（衝突）します。

**「ブランチを作り直す」必要はありません。**

以下の手順で、最新の `develop` の変更を、自分のブランチに取り込みましょう。

### リバースマージ手順

1. **ローカルの `develop` を最新にする**
   まずは、リモートの最新状態を手元の `develop` に持ってきます。

    ```bash
    git checkout develop
    git pull origin develop
    ```

1. 自分のブランチに戻る

    ```bash
    git checkout feature/A
    ```

1. develop を自分のブランチにマージする 「自分のブランチ に develop を 入れる」操作です。

    ```bash
    git merge develop
    ```

#### コンフリクトの解消（バージョン番号など）

この時、共通ファイル（バージョン番号など）でコンフリクトが発生することがよくあります。 `04_fix_and_recovery` の章と同じ手順で解消してください。

1. コンフリクトしたファイルを開く。

1. `<<<<` `====` `>>>>` を見て、正しい状態（基本的には新しいバージョン番号と、自分の追加コードの両方）に修正する。

1. `git add .` -> `git commit -m "developの変更を取り込み（コンフリクト解消）"`

これで、あなたのブランチは「最新のコード」かつ「自分の変更も入っている」最強の状態になります。安心して開発を続けてください。

## 完了したら

すべての課題がクリアできれば、本リポジトリの内容は修了です！
